#!/usr/bin/env python
# coding: utf-8

# # 功能說明
# ＊理解binarary search tree過程參考資料：
# 1. http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html
# 
# 2. 演算法圖鑑 by石田保輝 ＆ 宮崎修一

# **以下的不同功能說明先後順序是按照我寫的時候的順序寫的: 新增 -> 搜尋 -> 刪除 -> 修改**

# 1. 新增insert的部分：
# 
#    如果一開始沒有找到root，就把值放入TreeNode，再放入新增的節點當中，然後回傳。
#    
#    如果有root:
#    
#    新增的值小於等於root的值時往左走，大於的話就往右，走到沒有root時就新增並回  
#    傳，若找不到的話就呼叫自己。

# 2. 搜尋search的部分：
# 
#    如果沒有找到root，就回傳None。
#    
#    有的root的話，有以下三種情況:
#    
#    1. 目標跟root值相等，就回傳root
#    
#    2. 目標值小於root值，就繼續往左走，找到或找不到為止。
#    
#    3. 目標值大於root值，就繼續往右走找，找到或找不到為止。

# 3. 刪除delete的部分：
#    delete  這個函式呢 會收到一個需要刪減的樹的頭 root，還有一個 需要刪減的目標 target 數字，從這棵樹中找到所有ｖａｌ值= target的 節點，刪除後  最後的樹仍需要符合binary search tree的規範，首先 要找到 val值與target 一樣的節點 這個前面 search 的時候有寫過了，但是 在刪除節點的時候 我們需要 父節點 跟 子節點 的資訊，所以這次在找的時候 我們需要額外紀錄 當前節點的父節點資訊，做法上 我們可以重新寫一次 search  並且加上紀錄父節點的功能，或者是 在構建樹的時候 順便把父節點也記錄下來。這裡我們直接再寫一次search 不去改其他地方!
#    
#    那 再來 因為 跟linklist相比  子節點有兩個 讓情況複雜化了，需要考慮 當有 0 1 2 個 子節點的時候的情況
# 
#     左邊要找最大：往右下走
#     右邊要找最大：往左下走
#     不過呢，以助教給的例子來說，因為像是 3重複的數字會擺在左下角，因此我們就用右邊的最小數字來取代，比較不會遇到問題！

# 4. 修改modify的部分：
# 
# ##(我在這邊要提一下我在這部分為了要計算出他整棵樹總共有幾個需要改的數字)
# 
# 
# ##所以呢我在後面有多寫一個 count_val 的部分～
# 
#     簡單來說modify分成三個部分：
#     1. (利用我在後面所加的count_val功能)算出有幾個需要修改的點
#     2. 刪掉要修改的點 
#     3. 新增回原本的樹  
