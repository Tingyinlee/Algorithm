## Dijkstra與Kruskal原理說明  
  
### Shortest Path (Dijkstra): 
該方法用於計算由某個頂點到其他頂點的最短路徑。
Dijkstra algorithm 和 Bellman-Ford algorithm一樣，都是用以解決最短路徑問題的演算法，求出從起點到終點之間，邊權重總和最小的路徑。

>[小知識：]
這個演算法的名稱，得名自開發者艾茲赫爾・戴克斯特拉 (Edsger Wybe Dijkstra) 。他在1972年獲頒圖靈獎 (Turing Award)。

>[解說：]
相較於對所有的邊進行權重計算和更新的貝爾曼-福特演算法，戴克斯特拉演算法注重於選擇頂點，進而有效率地求出最短路徑。
假設輸入圖形的點點數為n、邊數為m，未仔細研究選好頂點時的執行時間是O(n⌃2) ; 能夠對資料結構下功夫的話，執行時間能壓縮到O(m + n log n)。

>**補充：迴圈中有負權中時並不存在最短路徑。貝爾曼-福特演算法可以判定出最短路徑不存在，但就算最短路徑不存在，戴克斯特拉演算法也會將錯誤的最短路徑當作正確答案。因此，戴克斯特拉演算法無法用於有負權重的圖形。

*＊總結來說：如果邊沒有負權重，選擇執行時間較短的戴克斯特拉演算法較佳 ; 邊有負權重時，則選用執行時間雖然較長，卻可以正確求解的貝爾曼-福特演算法*

> For Example:
想要知道從高雄到台南，如果開車的話，通常會利用查詢的交通網路來取得: 最 短路徑或者走哪一條路最符合經濟效益。諾以圖形網路來思考，就是任意兩個頂 點之間的最短路徑或最少花費。
***
###  Minimum Spanning Tree (Kruskal): 
Kruskal演算法是一種用來尋找最小生成樹的演算法。
Kruskal Algorithm 為建立 MST 的其中一種方法。該演算法將各邊線依權值大小由 小到大排列，從權值最低的邊線開始架構 MST，依序拿最小成本的邊來搭建 MST， 如果加入的邊線會造成迴路則捨棄不用，直到加入了|V|−1 條邊線為止。

>[小知識：]
由Joseph Kruskal在1956年發表。用來解決同樣問題的還有Prim演算法和Boruvka演算法等。三種演算法都是貪婪演算法的應用。和Boruvka演算法不同的地方是，Kruskal演算法在圖中存在相同權值的邊時也有效。

>[解說：什麼叫最小生成樹？ ]
已知一個無向連通圖，那麼這個圖的最小生成樹是該圖的一個子圖，且這個子圖是一棵樹且把圖中所有節點連線到一起了。一個圖可能擁有多個生成樹。一個帶權重的無向連通圖的最小生成樹（minimum spanning tree），它的權重和是小於等於其他所有生成樹的權重和的。 
生成樹的權重和，是把生成樹的每條邊上的權重加起來的和。

一顆最小生成樹有多少條邊？ 
已知帶權重無向連通圖有V個節點，那麼圖的最小生成樹的邊則有V-1條邊。

> For Example:
MST 有很多實際應用，將網路頂點看做城市，邊看做連線城市的通訊網，邊的權重看做連線城市的通訊線路的成本，根據最小生成樹建立的通訊網就是這些城市 之間成本最低的通訊網。其中如果有相同權值的邊線時，MST 並非唯一 ; 如邊線的權值均不同，則 MST 唯一。
