
了解BFS+DFS流程圖及原理的參考資料：
1. 演算法圖鑑 by石田保輝 ＆ 宮崎修一
2. BFS原理參考：https://zh.wikipedia.org/wiki/广度优先搜索
3. DFS原理參考：https://zh.wikipedia.org/wiki/深度优先搜索
4. 老師上課的PPT參考內容：

    a. https://docs.google.com/presentation/d/e/2PACX-1vSYJYXUXvGAeTZ5fknxj_-EPm3zxgy4ITdImrXzy63Y-iZgs8uwVNmOaZlnx9fUNzsbo8kphvMTa0c4/pub?start=false&loop=false&delayms=3000&slide=id.g7a5d8b85ee_0_0
    
    b. https://docs.google.com/presentation/d/e/2PACX-1vTma_vOZyE70O23KWw4I4Y78aAaT5fJSTq7Mae912kCwka_u5ZMWPoo14D86-x-57kZPbb6hAGktSW4/pub?start=false&loop=false&delayms=3000&slide=id.g7a5d8b85ee_0_0

# BFS & DFS流程圖：

[] (https://raw.githubusercontent.com/Tingyinlee/Algorithm/master/Pictures/4.jpg)

### BFS steps:

>1. 首先將根節點放入佇列中。
>2. 從佇列中取出第一個節點，並檢驗它是否為目標：
>>a. [如果找到目標，則結束搜尋並回傳結果。]
    b. [否則將它所有尚未檢驗過的直接子節點加入佇列中。]
>3. 若佇列為空，表示整張圖都檢查過了——亦即圖中沒有欲搜尋的目標。結束搜尋並回傳「找不到目標」。
>4. 重複步驟2。

### DFS steps:
>1. 首先將根節點放入stack中。
>2. 從stack中取出第一個節點，並檢驗它是否為目標。
>>a.[如果找到目標，則結束搜尋並回傳結果。]
    b.[否則將它某一個尚未檢驗過的直接子節點加入stack中。]
>3. 重複步驟2。
>4. 如果不存在未檢測過的直接子節點。
>>a.[將上一級節點加入stack中。]
   b.[重複步驟2。]
>5. 重複步驟4。
>6. 若stack為空，表示整張圖都檢查過了——亦即圖中沒有欲搜尋的目標。結束搜尋並回傳「找不到目標」。

# BFS + DFS原理：

### Breadth-First-Search (廣度優先搜尋BFS): 
是圖形搜尋的演算法，從根節點開始，沿著樹的寬度遍歷樹的節點。如果所有節點均被存取，則演算法中止。抵達頂點時，可以判定這個頂點是否為目標頂點。BFS在搜尋頂點時，優先搜尋離起點較近的頂點。
> For Example:
今天不小心把隱形眼鏡弄掉時，會先蹲下去找離自己最近的地方，再去找遠一點的地方...XD

***
###  Depth-First-Search (廣度優先搜尋DFS): 
一種用於遍歷或搜尋樹或圖的演算法。沿著樹的深度遍歷樹的節點，儘可能深的搜尋樹的分支。當節點的所在邊都已被探尋過，搜尋將回溯到發現節點的那條邊的起始節點。這一過程一直進行到已發現從源節點可達的所有節點為止。如果還存在未被發現的節點，則選擇其中一個作為源節點並重複以上過程，整個行程反覆進行直到所有節點都被存取為止。
深度優先搜尋是圖論中的經典演算法，利用深度優先搜尋演算法可以產生目標圖的相應拓撲排序表，利用拓撲排序表可以方便的解決很多相關的圖論問題，如最大路徑問題等等。
> For Example:
假如今天你走進一個迷宮裡，不可能自己分身站在每個走過的位置，所以只能一直往更深的地方走(不撞南山不回頭的感覺)。


# BFS & DFS比較：

##### 兩者皆是圖形搜尋的演算法，兩種演算法的目的同樣都是從起點抵達指定頂點（目標頂點)。

>  ### 1. 走訪方式不同： 
當走訪完某個點後，BFS會依序走訪該點所有相鄰且未走訪過的點; DFS則接著走訪該點第一個相鄰且未走訪過的點。

[BFS：頂點選項是用「先進先出」(FIFO)的方式管理，所以可以用「佇列」(queue)的資料結構][DFS：頂點選項是用「後進先出」(LIFO)的方式管理，所以可以用「堆疊」(stack)的資料結構]
>> ### 補充：
如果今天遇到「封閉迴圈」(closed circuit)的情況，也就是迴圈為起點和終點在相同路徑上的狀態，此種迴圈存在時也能用同樣的方法搜尋。

>  ### 2. 時間複雜度： 
**BFS:**  
最壞的情況下，每個頂點至少訪問一次，每條邊至少訪問1次，這是因為在搜尋的過程中，若某節點向下搜尋時，其子結點都訪問過了，這時候就會往回退，故時間複雜度為O(E)，演算法總和的時間複雜度為O( | V |+| E | )。                                                                                                      
**DFS:**  
概念和BFS相同。

>  ### 3. BFS相對DFS更耗記憶體空間： 
BFS每次找尋下一個訪尋的點時都需借助一個Queue來儲存，把待訪尋的陣列state1 用Queue來儲存，並把最先進入state1的點取出，因此空間複雜度與點數成正比。DFS在找尋下一個訪尋的點實則不需借助一個Stack來儲存，因為待訪尋的陣列state1本身就可視作一個stack，只需直接把下一個訪尋點從state1中pop出來。

>  ### 4. DFS在某些情況下會相當耗時：
深度搜尋法雖然可以搜尋整個圖形，可是搜尋方向固定，因此若子節點個數一多，或遇到特殊情況，必須要繞所以子結點才可以找到目標，那麼，會相當耗時間，狀況壞的話，電腦可能無法執行，無法負荷，相當的不方便。

## 學習歷程： 

這次的作業對我來說整體來說是比較容易一點點的，雖然我對於BFS跟DFS的概念覺得好像蠻容易理解的，但當我一開始在利用老師PPT上給的示範，試著手寫看看走訪歷程的時候，竟然會覺得很卡，覺得沒有我想像的那麼容易，尤其是BFS跟DFS在轉換的時候，我覺得這部分其實挺複雜的！

當我開始著手寫程式時，一開始我把它想得太複雜，結果想破頭，先冷靜一天之後，無意間在我逛蝦皮買東西時，我在把我“想要買”的東西先按愛心加入「願望清單」時，我突然間頭腦中好像有顆燈泡瞬間被點亮了！ 因為我想到這不就跟我要寫的BFS+DFS概念有一點點像嗎？ 買過的東西加到了曾經的訂單清單中(走訪過的清單visted_list); 然後先前看到想要買，但還沒下手的東西就先放到[願望清單wish_list]內。

把程式中過程的概念想成我生活中活生生的例子時，我這腦子不太好使的人，瞬間就懂了，這次的解code過程感覺也很棒，因為覺得寫程式的邏輯其實跟生活息息相關時，就不會覺得那麼乏味，甚至還蠻開心的！：）



```python

```
