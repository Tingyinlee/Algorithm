# -*- coding: utf-8 -*-
"""hash_table.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mJaFBaQyGthzZqd3Y4Vupt4VyKLzkxoh
"""

!pip install pycryptodome

from Crypto.Hash import MD5

class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None
        """
        :type val: int
        :type next: ListNode
        :rtype: None        
        """
class MyHashSet:
    def __init__(self, capacity=5):
        self.capacity = capacity
        self.data = [None] * capacity
        """
        :type capacity: int
        :rtype: None
        """
    
    def get_MD5_int(self, key):
        h = MD5.new()
        h.update(key.encode())
        return int(h.hexdigest(), 16)
    
    def add(self, key):
        """
        :type key: int
        :rtype: None
        """
        md5_num = self.get_MD5_int(key)
        data_loc = md5_num % self.capacity

        #empty slot
        if not self.data[data_loc]:
          new_node = ListNode(md5_num)
          self.data[data_loc] = new_node
        #collision happened 
        else:
          cur_node = self.data[data_loc]
          while cur_node.next:
            cur_node = cur_node.next
          new_node = ListNode(md5_num)
          cur_node.next = new_node
        

    def remove(self, key):
        """
        :type key: int
        :rtype: None
        """
        md5_num = self.get_MD5_int(key)
        data_loc = md5_num % self.capacity
        
        cur_node = self.data[data_loc]
        #1st link list
        if cur_node and cur_node.val == md5_num:
          new_head = cur_node.next
          # if multiple node need to remove at 1st link list
          while new_head and new_head.val == md5_num:
            new_head = new_head.next
          self.data[data_loc] = new_head

        #from 2nd link list to the end  處理完頭之後 再來從第二個開始往下刪
        cur_node = self.data[data_loc]  #重新指定一次頭
        while cur_node and cur_node.next: #如果next還有東西
          if cur_node.next.val == md5_num:  #如果下一個點的數值有比對到
            remain_node = cur_node.next.next #留下來的點就指定到next的next
            while remain_node and remain_node.val == md5_num:  #處理重複比對情況直到沒有重複
              remain_node = remain_node.next 
            #get final remain_node 
            cur_node.next = remain_node #把被刪掉點的next接到前一個點cur_node後面

          cur_node = cur_node.next #當前處理的節點往後一個


    def contains(self, key):
        """
        :type key: int
        :rtype: bool(True or False)
        """
        md5_num = self.get_MD5_int(key)
        data_loc = md5_num % self.capacity

        #slot non-empty
        cur_node = self.data[data_loc]
        while cur_node:
          if cur_node.val == md5_num:
            return True
          cur_node = cur_node.next
        return False

hashSet = MyHashSet()
hashSet.add("dog")
hashSet.add("pig")
rel = hashSet.contains('pig')
print(rel)
rel = hashSet.contains('dog')
print(rel)
rel = hashSet.contains('cat')
print(rel)
hashSet.add("bird")
rel = hashSet.contains('bird')
print(rel)

hashSet.remove('pig')
rel = hashSet.contains('pig')
print(rel)